Permit commas in numbers.  There's an old paper on novices learning
PASCAL (I think?) that says this could be a big deal.

Maybe have types for different types of time.  1s versus 1 minute,
etc.  Addition and subtraction operators would be defined on them
easily.


Rename types.  Strings and Bools really should not be Strings and
Bools.  May be way to perform intermediate study on Mechanical Turk.

Transfer comments into generated code.

Tension between flexibility and inflexibility:
Allowing people to write code in most natural way for them means that
others cannot read it.  Programming language that supports flexible
re-composition.  (Should facilitate large structural changes back and
forth so that people can view in own best way, and translate to what
they like ----> View message stream inline vs. separated by endpoint.

Name each message line.  Idea is that want to present error messages
with context.  Any code that has a separate internal mental
representation should have a proper noun so that it can be referenced
in error messages and leverage priming.

Maybe goal of Waldo is to support Epistemic actions.  Trace line.
Something that does not move directly closer to goal, but which
reduces cognitive load.  (Part of that could be re-arranging source
more easily.)




When writing about this, stress: we do not have a polished and
finished feature.  We are evaluating a pre-alpha version of a feature
against libraries that are being used by hundreds and thousands
commercially and recreationally (well-used and popular).  We do not
have popular, but ancillary features, such as named arguments, lint
tools, etc.  Very much setting a lower bound on usefulness of process
and feature.  (Abstract data types, variadic arguments, default
arguments, etc.)

Goal of language is for a complete language user guide to take less
than 2 pages.  As such, eschewing high-level features.


Error Reporting:

The error message should contain a link to the section of the
rules that the statement violates.  (high-level) to assess: whether
that reduces the frequency of bugs faster.

Have waldo scripts compiled by a server, make waldo scripts a
service.  This way, can see how it's being used, common bugs, and
evolve error messages, and feedback.

Compiler error messages are doing interesting things, such as
reporting function text/listing as part of error message, when have a
collision, shows where collision is, etc.  These are independently
interesting questions.

Maybe have a warning when performing equality tests on lists and
maps.  Frequent challenge in equality testing.
