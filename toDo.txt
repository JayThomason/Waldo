Command to run from parser/ast/ 
    ./head.py -f testBasic.wld -go '{"file":"astOut.html", "h": 3000, "w": 5000}' -e emitted.py


In examples:
may want to make Ready a keyword so that do not have conflicts with
sending messages.

What about public function names in general so that do not have
conflicts with python?  should they be p_Something?
  
Ignoring connection setup.

Ignoring checks to make sure that the connection is set up before
continuing.  Maybe block until the connection is set up?

May want to use underscores for all data internal to an endpoint in
generated code to discourage direct access

For Contexts, may want to use a different name from myPriority and
theirPriority.  May have some variables begin with underscores, and
some generic variables begin with two or three underscores.

Handle deep copies in contexts.

Handle deep copies of internal variables.

Make concrete decisions about what should happen if a public method
generates a conflict with data we are operating on.


Playing fast and loose with the names of variables that the user can
pass in as arguments in emitting.  Fix.

Throw an error if a Send LKJDJ To LKJljdf appears in anything besides
a message receive and message send function.  If it appears in a tail
msg receive function, throw an error.

May want to provide a commit callback to fire when action is totally
finished on both sides.

Im emitting:
    
Lots of todos still in code.  Largest: sort through initializers for
variables and finish runFunctionBodyInternalEmit.

Decide on whether can pass messages through function calls.

Decide on whether can use a message literal in a send statement.
(Parse for it too, maybe).

Maybe make messages immutable???

    
To Do:

 * Actually perform type check for send statements.  (And functions
   with sends in them.  Right now, skipping that and printing a
   warning instead.)

 * Currently producing syntax errors when have not filled in lines in
   traces sections or if don't have functions defined in an endpoint
   section.  These are poor errors.  Instead, may want to produce a
   type check error.

 * Not handling escaping strings for string literals correctly when
   emitting in runFunctionBodyInternalEmit of astEmit.py.
   
 * Throw okay error if do not name endpoint at top endpoint section
   correctly (eg., name both the same thing).

 * To do: right now, cannot handle parsing negative numbers.
   
 * To do: right now, have problem where if function takes no
   arguments, try to type check EMPTY statements.  (prints these as
   well.  probably want to parse differently so that these don't show
   up.)
   
 * Throw better error if we add an identifier that we already have
   declared (see addIdentifier of astTypeCheckStack.py).

 * Think through what arguments msgReceive function should take, and
   throw type errors if get more info.
 
 * For incorrectly declared variables, maybe present some "you may
   have meant XXXXX" error message.
   
 * Test that do not write to any variable that do not control.
   
 * Determine syntax for generics Map and List; determine if want
   syntax for doing things by value
   
 * Eventually, may want to lex/parse for common errors.  For instance,
   if use "Equals" instead of "==", parse for "==" and report error.
   +=, ++ as well.  Cannot begin a variable name with _
   
   
 * Warn unused functions.  Error on unused functions?

 * Need to ensure that all msgReceive functions have same type
   signature.

 * Ensure that nothing makes a function call to a msgReceive function.
 
 * Need to better-define ReturnableExpression.  Right now, can only
   provide literals and function calls.
 * During semantic analysis, if have more than one argument in
   funcArgList, check that no arguments are empty.

 * Is it possible to specify shared functions?  What about shared
   msgSend and msgReceive functions?

----------------------------
Emitting:
 * Not handling initializer expressions for variables correctly.
   Search for FIXME in astEmit.py.

 * varName method of endpoint should try to avoid conflicts with
   internal python keywords (such as self, not, and, etc.)
   
   

   
Major to dos:
  1) Decide on how discovery should work
  2) Determine exact rules for trying to send a message (do you queue
     more than one message, etc.)
  3) Specifying error conditions/what happens on error/after some time
  4) What is structure of message?  Can we type check it?
  5) How does time play into when respond?  Do we have a notion of
     time/timers?  What is it?
  5) Come up with overall experiment
  6) Come up with ideal micro-evaluations
     -Turk for names "Bool" vs "TrueFalse"; "String" vs "Text".
  7) Decide which target to generate code for (likely python).
  8) Decide on interface between target code and existin code
     -What visualizations allow programmer to see how things work?
  9) Decide on visualizations to present error messages and do some
     work on what error messages should look like.
   
   
Notes:
  Ors and Ands have same precedence and are left-associative.



  
Questions:

Should decide whether should have basic initializers for variables or
allow for more complex statements (returnable expressions).

Annotation for shared data seems off.  Right now, just have one
general CONTROLS annotation.  Can have more nuanced rules, where a
piece of state can only be modified directly in a message response
chain instead of at the outset of response.  Similarly, may want to
make state only writable.  We'll see.

Should ElseIf use camel-case or underscore?  Mechanical Turk it.


Ideas:

Are there any benefits behind reporting syntax errors sequentially,
instead of reporting many at once?  That would be conventional wisdome
to overturn.

Syntax error reporting is hard.  This is because when hit a syntax
error, yacc does not actually report to you which state it can't get
out of (or the deepest state that it can get into before failing).
This is a problem because can't report targetted syntax errors without
parsing for them specifically.  If provide this extra bit of
information, maybe can provide more informative syntax error: "looks
like you may have forgotten a semi-colon", "don't forget a comma
here", etc.  Note that this may fit in with SOSP paper about
configuration error messages.


Dual Process Theory may define what it means to be a novice language
and a non-novice language.  No one else has suggested why an expert
would no longer use a novice language.  Dual Process Theory may be a
tool to identify and explain the fundamental tradeoffs in language design.

Identifies a fundamental language tradeoff between expressiveness
and readability.  Probably a natural metaphor with command line versus
gui.  

According to a lot of our theory, we should be able to re-design
Haskell to have a much lower learning curve by changing around a lot
of its syntax.  Maybe think about doing that as evaluation for paper.

Special language for configuration files.  Maybe throw error when
overwrite variable's existing value.  Maybe throw warnings when
variables are named very closely to one another.


Should == be "IsEqualTo" and != be "IsNotEqualTo"?  This really,
really depends on our target.  It's a fundamental tradeoff.  

I really think that the function declaration syntax needs more work.
It should reflect, these things come in, those things go out.

Something of a Public <FunctionName> : In { };
                                       Out{ };
                                       WhatToDo
                                       {

                                       }
Of course, keep in mind it depends if we're targetting novices or not.  


Require parens for grouping on == and !=. 
Require parens for grouping on or and and?
Maybe make multiplicatino be with x?

 
Long-term to do:
 

Incorporate errors into Trace syntax.  Probably put errors at end of
each trace line.  (Ie, for each trace line, no matter where the error
occurs in the trace line, all error handling on each side happens in
one function.)  Use prose keyword, such as "OnError" to deal with
each.  Maybe also provide ability to specify how long to wait until a
message times out.

Presumably, only one trace line can execute at a time.  What is model
for queueing other message lines?


