from parser.ast.astLabels import *
from slice.typeStack import TypeStack
import emit_utils
import parser.ast.typeCheck as TypeCheck

def emit_statement(
    statement_node,endpoint_name,ast_root,fdep_dict,emit_ctx):
    '''
    @returns {String}
    '''
    statement_txt = ''
    if statement_node.label == AST_IDENTIFIER:
        statement_txt = _emit_identifier(statement_node)

    elif statement_node.label == AST_FUNCTION_BODY_STATEMENT:
        for child_node in statement_node.children:
            statement_txt += emit_statement(
                child_node,endpoint_name,ast_root,fdep_dict,
                emit_ctx)

    elif statement_node.label == AST_ASSIGNMENT_STATEMENT:
        statement_txt = _emit_assignment(
            statement_node,endpoint_name,ast_root,fdep_dict,emit_ctx)
            
    else:
        emit_utils.emit_warn(
            'Unknown label in emit statement ' + statement_node.label)

    return statement_txt




def _emit_assignment(
    assignment_node,endpoint_name,ast_root,fdep_dict,emit_ctx):
    '''
    @param {AstNode} assignment_node --- corresponds to node labeled
    AST_ASSIGNMENT_STATEMENT

    The lhs node is a comma list.  The comma list will always have
    only one element whenever the right hand side is not a function
    that is being called.  The comma list may or may not always be a
    single element when issuing a function call.
    
    '''
    #### DEBUG
    if assignment_node.label != AST_ASSIGNMENT_STATEMENT:
        emit_utils.emit_assert(
            'assignment_node must be an identifier')
    #### END DEBUG

    # always assigning to a comma list of variables.
    comma_list_node = assignment_node.children[0]
    rhs_node = assignment_node.children[1]


    #### DEBUG
    if comma_list_node.label != AST_OPERATABLE_ON_COMMA_LIST:
        emit_utils.emit_assert(
            'Should only assign to a comma list')
    #### END DEBUG

    # strategy, assign into intermediate values: _tmp0, _tmp1, _tmp2,
    # etc., for each element in the tuple.  after that, actually,
    # match each to the place they go in Waldo
    intermediate_assign_txt = ''
    for counter in range(0,len(comma_list_node.children)):
        intermediate_assign_txt += '_tmp' + str(counter)
        if counter != len(comma_list_node.children) -1:
            intermediate_assign_txt += ','


    if emit_utils.is_function_call(rhs_node):
        func_call_txt = emit_statement(
            rhs_node,endpoint_name,ast_root,fdep_dict,emit_ctx)

        if emit_utils.is_endpoint_func_call(rhs_node):
            # execute the function call before 
            intermediate_assign_txt = func_call_txt + '\n' + internmediate_assign_txt
            # emitting an endpoint function call stores values in
            # _queue_elem
            # FIXME: it sucks that _queue_elem is hard-coded
            to_assign_text = '_queue_elem.to_return'
        else:
            to_assign_text = func_call_txt

    else:
        to_assign_txt = emit_statement(
            rhs_node,endpoint_name,ast_root,fdep_dict,emit_ctx)

    first_level_assign_txt = intermediate_assign_txt + ' = ' + to_assign_txt + '\n'


    # after first level assign, can take each individual element from
    # function list
    return first_level_assign_txt +_emit_second_level_assign(
        comma_list_node,endpoint_name,ast_root,fdep_dict,emit_ctx)


def _emit_second_level_assign(
    comma_list_node,endpoint_name,ast_root,fdep_dict,emit_ctx):
    '''
    extAssign _ to a, b = func_call()
    
    (extAssign _ a) and b will each be children of comma_list_node

    We are trying to assign all elements of the comma_list_node to
    intermediate variables generated by _emit_assignment.  For each
    node in comma_list_node, we should have a corresponding
    intermediate variable named _tmpX that we want to assign to it
    (where X is the number of the node in the comma
    list....0,1,2,3...)
    '''
    # gets returned at end of function
    all_assignments_txt = ''
    for counter in range(0,len(comma_list_node.children)):
        lhs_node = comma_list_node.children[counter]
        
        ext_assign = False
        if lhs_node.label == AST_EXT_ASSIGN_FOR_TUPLE:
            # notes that we are performing an assignment to an ext and
            # unwraps the extAssign.
            ext_assign = True
            lhs_node = lhs_node.children[0]

        to_assign_txt = '_tmp' + str(counter)
        if not ext_assign:
            to_assign_txt = '_context.get_val_if_waldo(' + to_assign_txt + ')'
            
        if lhs_node.label == AST_BRACKET_STATEMENT:
            # need to actually assign to a particular key, rather than the
            # overall variable.  can't use write_val, must use
            # write_val_on_key instead.
            outside_bracket_node = lhs_node.children[0]
            inside_bracket_node = lhs_node.children[1]

            outside_txt = emit_statement(
                outside_bracket_node,endpoint_name,ast_root,fdep_dict,emit_ctx)
            # FIXME: declare method in WaldoExecutingContext for
            # _get_val_if_waldo.  Essentially, in cases where unsure
            # if using a non-waldo number, string, etc. or a waldo
            # variable, and want to use the value type, this gives the
            # value type.
            inside_txt =  '_context._get_val_if_waldo(%s)' % (
                emit_statement(
                    inside_bracket_node,endpoint_name,
                    ast_root,fdep_dict,emit_ctx))
                                    
            to_assign_to_txt = (
                outside_txt +
                '.get_val(_active_event).write_val_on_key(_active_event,' +
                inside_txt + ',' # gives key for map writing into
                                 # still need actual value
                )
            
        else:
            # was not a bracket statement, can just call write_val
            # directly
            to_assign_to_txt = emit_statement(
                lhs_node,endpoint_name,ast_root,fdep_dict,emit_ctx)

            to_assign_to_txt += '.write_val(_active_event,'
            
        all_assignments_txt += to_assign_to_txt + to_assign_txt + ')\n'

                      
    return all_assignments_txt
    
    
def _emit_identifier(identifier_node):
    '''
    @param {AstNode} identifier_node --- corresponds to node labeled
    AST_IDENTIFIER
    '''
    #### DEBUG
    if identifier_node.label != AST_IDENTIFIER:
        emit_utils.emit_assert(
            'statement_node must be an identifier')
    #### END DEBUG
        
    # FIXME: not handling dot statements for user structs here
        
    identifier_txt = ''
    id_annotation_name = identifier_node.sliceAnnotationName
    id_annotation_type = identifier_node.sliceAnnotationType
    if id_annotation_type in [TypeStack.IDENTIFIER_TYPE_LOCAL,
                              TypeStack.IDENTIFIER_TYPE_FUNCTION_ARGUMENT]:
        # means that we can just address the variable directly
        identifier_txt = identifier_node.value

    elif id_annotation_type in [TypeStack.IDENTIFIER_TYPE_ENDPOINT_GLOBAL,
                                TypeStack.IDENTIFIER_TYPE_SHARED]:
        # get value from endpoint's global store
        identifier_txt = '_context.global_store.get_var_if_exists("%s")' % (
            id_annotation_name)
    elif idAnnotationType in [TypeStack.IDENTIFIER_TYPE_MSG_SEQ_GLOBAL,
                              TypeStack.IDENTIFIER_TYPE_MSG_SEQ_GLOBAL_AND_FUNCTION_ARGUMENT]:
        identifier_txt = '_context.sequence_local_store.get_var_if_exists("%s")' %(
            id_annotation_name)
    #### DEBUG
    else:
        emit_utils.emit_assert(
            'Unknown annotation on identifier')
    #### END DEBUG
    return identifier_txt



